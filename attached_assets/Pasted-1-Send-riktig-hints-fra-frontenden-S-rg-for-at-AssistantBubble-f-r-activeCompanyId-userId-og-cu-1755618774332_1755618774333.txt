1) Send riktig â€œhintsâ€ fra frontenden

SÃ¸rg for at AssistantBubble fÃ¥r activeCompanyId, userId og currentRoute. Hent dem fra din appâ€‘context (der du allerede vet aktiv bedrift) â€“ og pass dem inn.

// AppRoot.tsx (eller der bobla rendres)
import AssistantBubble from "@/components/AssistantBubble";
import { AssistantActionListener } from "@/components/AssistantActionListener";
import { useAppContext } from "@/lib/appContext"; // ditt eget

export default function AppRoot({ router }) {
  const { activeCompanyId, currentUser, currentRoute } = useAppContext();

  return (
    <>
      <AssistantActionListener router={router} />
      <AssistantBubble
        userRole={currentUser?.role ?? "SELGER"}
        activeCompanyId={activeCompanyId ?? localStorage.getItem("activeCompanyId") ?? ""}
        currentRoute={currentRoute}
        userId={currentUser?.id ?? ""}
      />
    </>
  );
}


I AssistantBubble.tsx: sÃ¸rg for at du sender disse i fetch("/api/assistant"):

body: JSON.stringify({
  messages: newMsgs,
  hints: { role: userRole, activeCompanyId, currentRoute, userId }
})


ğŸ‘‰ Uten activeCompanyId vil alle DBâ€‘kall som har .eq("company_id", ...) returnere 0 rader.

2) Normaliser regnr (PRâ€‘52981 â‡¢ PR52981) og bruk korrekt kolonne

KjÃ¸r denne enkle migrasjonen (oppdater coalesceâ€‘listen hvis din kolonne heter noe annet):

create or replace view cars_secure_norm as
select
  c.*,
  upper(regexp_replace(
    coalesce(c.registration, c.regnr, c.license_plate, ''),
    '\s|-', '', 'g'
  )) as regnr_norm
from cars_secure c;

create or replace view cars_secure_with_age as
select
  csn.*,
  (current_date - csn.created_at::date) as days_on_lot
from cars_secure_norm csn;


I serverkoden bruk regnr_norm:

// assistantTools.ts
function normReg(x:string){ return (x||"").toUpperCase().replace(/[\s-]/g,""); }

export async function getCarByReg(regInput: string, hints: UserHints) {
  const reg = normReg(regInput);
  let q = supabase
    .from("cars_secure_with_age")
    .select("id, company_id, registration, status, sale_price, brand, model, year, days_on_lot")
    .eq("regnr_norm", reg)
    .limit(1);

  if (hints.companyId) q = q.eq("company_id", hints.companyId); // filtrer bare hvis vi har id
  const { data, error } = await q;
  if (error) throw error;
  return data?.[0] ?? null;
}

3) â€œSolgtâ€ via kontrakter (ikke status pÃ¥ bil)

Hvis â€œdyreste solgteâ€ gir tomt resultat, skyldes det ofte at salget bor i contracts. Lag en enkel view:

create or replace view sold_cars_v as
select
  ct.company_id,
  ct.id   as contract_id,
  cr.id   as car_id,
  cr.brand, cr.model, cr.year, cr.sale_price
from contracts ct
join cars cr on cr.id = ct.car_id
where ct.status in ('FullfÃ¸rt','Betalt','Levert');  -- tilpass til dine statuser


Og oppdater verktÃ¸yet:

export async function getMostExpensiveSold(brandFragment: string | null, hints: UserHints) {
  let q = supabase
    .from("sold_cars_v")
    .select("company_id, car_id, brand, model, year, sale_price")
    .order("sale_price", { ascending: false })
    .limit(1);

  if (hints.companyId) q = q.eq("company_id", hints.companyId);
  if (brandFragment) q = q.ilike("brand", `%${brandFragment}%`);

  const { data, error } = await q;
  if (error) throw error;
  return data?.[0] ?? null;
}

4) FÃ¥ â€œÃ¥pne siden nÃ¥â€ til Ã¥ fungere nÃ¥r bruker svarer â€œjaâ€

To alternativer â€“ velg A (enklest):

A) HÃ¥ndter â€œjaâ€ i klienten (ingen serverside state)

Lag en liten â€œsist verktÃ¸yâ€â€‘buffer i bobla:

// AssistantBubble.tsx
const lastToolRef = useRef<any>(null);

async function send() {
  // ...
  const data = await res.json();
  if (data?.tool) {
    lastToolRef.current = data.tool; // husk for "ja"
    window.dispatchEvent(new CustomEvent("assistant:action", { detail: data.tool }));
  }
  if (data?.reply) setMsgs(m => [...m, { role: "assistant", content: data.reply }]);
}

useEffect(() => {
  // Hvis bruker skriver "ja", "ja takk", "Ã¥pne", "gjÃ¸r det" â€“ og vi har et nylig tool
  const lower = input.trim().toLowerCase();
  if (["ja","ja takk","Ã¥pne","gjÃ¸r det","please"].includes(lower) && lastToolRef.current) {
    window.dispatchEvent(new CustomEvent("assistant:action", { detail: lastToolRef.current }));
    setInput("");
  }
}, [input]);

B) (Mer avansert) Lag en â€œsession memoryâ€ pÃ¥ serveren og gi last_tool ved â€œjaâ€ â€“ ikke nÃ¸dvendig nÃ¥.
5) Intentâ€‘regex som faktisk fanger PRâ€‘52981 / BS 19507

I /api/assistant:

// Fanger bs19507, BS 19507, PR-52981
const regMatch = last.match(/([a-z]{2})[\s-]?(\d{5})/i);
const joinedReg = regMatch ? (regMatch[1] + regMatch[2]).toUpperCase() : null;

if (/(pris(en)? pÃ¥|hva koster)/i.test(last) && joinedReg) {
  // CAR_PRICE
}

if ((/er (bil|den)/i.test(last) && /(solgt|tilgjengelig|status)/i.test(last)) && joinedReg) {
  // CAR_STATUS
}

6) Hurtig test (2 minutter)

Bekreft hints: i devtools â†’ Network â†’ request til /api/assistant â†’ se at hints.activeCompanyId ikke er tom.

Regnr: SpÃ¸r

â€œHva koster PRâ€‘52981?â€

â€œEr BS 19507 solgt?â€
Forvent: konkret svar + forslag om Ã¥ Ã¥pne Rediger.

Dyrt salg: â€œHvilken Porsche er den dyreste vi har solgt?â€
Forvent: modell/Ã¥r + pris hentet fra sold_cars_v.

Svar â€œja takkâ€ etter et forslag â†’ skal Ã¥pne siden.

7) Vanlige feil Ã¥ sjekke

activeCompanyId mangler â†’ alle spÃ¸rringer blir tomme.

contracts.status bruker andre verdier enn 'FullfÃ¸rt','Betalt','Levert' â†’ justÃ©r viewet.

Regnr ligger i en annen kolonne â†’ oppdater coalesce(c.registration, c.regnr, ...) i viewet.

ActionListener er ikke montert â†’ toolâ€‘navigasjon gjÃ¸r ingenting. SÃ¸rg for at du har:

// AssistantActionListener.tsx
useEffect(() => {
  function onAction(e:any){
    const t = e.detail;
    if (t?.name==="open"){
      if (router?.push) router.push(t.page);
      else window.location.hash = t.page;
      // hÃ¥ndter modal/tab hvis du bruker global state
    }
  }
  window.addEventListener("assistant:action", onAction);
  return () => window.removeEventListener("assistant:action", onAction);
}, [router]);